from sklearn import clusterimport matplotlib.pyplot as pltimport matplotlibfrom mpl_toolkits.mplot3d import Axes3Dimport syssys.path.insert(0, '/Users/lukefarrell/Desktop/Customer_Forecasting')import Final_Data_Extractor as DataExtractorimport numpy as npimport time as time#Create a Global Master Dictionary for Event PlotMasterDict = {}#Instantiate the plot, if Event Plot == False will create a blank graph (nbd)fig = plt.figure()#Instantiate the plot as 3 Dimensionalax = fig.add_subplot(111, projection='3d') #-------------------------------------------------------- Create Main Clustering Function --------------------------------------------------def KClustering(ExtractNew, numClusters, EventPlot, ColorPlot):     #Start Timer    start = time.time()    print " "    global MasterDict	#Collect or Extract the Master Dictionary    MasterDict = DataExtractor.Main(ExtractNew)	#Put all the Customer IDs into a List    customerMatrix = []    testMatrix = []    Customers = []    for customer in MasterDict:        Customers.append(customer)    print "     Calculating Clustering..."        #Create Testing Set and seperate customers into Testing and Training    np.random.shuffle(Customers)        #Create Testing and Training Clusters with the variables you want to cluster based on    CustomerIDs = []    for x in range(int(len(Customers)*(1-0.1))):        customerMatrix.append(MasterDict[Customers[x]]["CLV"][2:5])        CustomerIDs.append(Customers[x])        TestCustomers = []    for x in range(int(len(Customers)*(1-0.1)),len(Customers)):        testMatrix.append(MasterDict[Customers[x]]["CLV"][2:5])        TestCustomers.append(Customers[x])    	#Run K-Means Clustering Algorithm    clustering = cluster.KMeans(n_clusters = numClusters, init = "k-means++", n_jobs = -1)    clustering.fit_transform(customerMatrix)    clusters = clustering.labels_    print "Clustering Complete:"	#Create a Dictionary of Customer to their Classification    ClassificationDict = {}    for customer in range(len(CustomerIDs)):        ClassificationDict[CustomerIDs[customer]] = clusters[customer]    #Create a Dictionary of Test Customers to their Classification and calculate Score (fitness)    testclusters = clustering.predict(testMatrix)    Score = clustering.score(testMatrix)    TestDict = {}    for x in range(len(TestCustomers)):        TestDict[TestCustomers[x]] = testclusters[x]            print "Testing Set Size   : ", len(TestDict)     print "Testing Set Score  : ", round(Score/1000000,3)    #Perform Event Plotting if EventPlot == True (Event Plotting takes a while)    if EventPlot == True:        print ""        print "Building Plot  : "        EventClusterPlot(customerMatrix, clusters,CustomerIDs)    else:        pass    if ColorPlot == True:        print ""        print "Building Plot  : "        ColorClusterPlot(customerMatrix, clusters,CustomerIDs)    else:        pass    #Print Total Time and All Clustering results to the next layer    print "------- TOTAL CLUSTERING TIME : ", round(time.time()-start,2), "s-------"     return MasterDict, ClassificationDict, TestDict#----------------------------------------------------- Optional Event Plotting Function (takes very long all one color)----------------------------------------------def EventClusterPlot(customerMatrix, clusters, CustomerIDs):	    Lifetime = []    NumVists = []    AvgSpent = []    #Iterate through each Customer & Add them to the scatter plot    for customer in range(len(customerMatrix)):        Lifetime = customerMatrix[customer][0]        NumVists = customerMatrix[customer][1]        AvgSpent = customerMatrix[customer][2]        #Plot based on their Lifetime, NumVisits, Avgerage Spending, color based on their cluster assignment, link them to their Customer ID        ax.scatter(Lifetime, NumVists, AvgSpent, c = clusters[customer], picker = True, gid =CustomerIDs[customer])    #Create Plot Label Axies    ax.set_xlabel('Life Time')    ax.set_ylabel('Num Visits')    ax.set_zlabel('Avg Spent')    #Allow for the click function to work    fig.canvas.mpl_connect('pick_event', onpick)    print "Plot Complete"    #Plot the Graph    plt.show()#----------------------------------------------------- Optional Cluster Plotting Function ----------------------------------------------def ColorClusterPlot(customerMatrix, clusters, CustomerIDs):        Lifetime = []    NumVists = []    AvgSpent = []    #Iterate through each Customer & Add them to the scatter plot    for customer in range(len(customerMatrix)):        Lifetime.append(customerMatrix[customer][0])        NumVists.append(customerMatrix[customer][1])        AvgSpent.append(customerMatrix[customer][2])        #Plot based on their Lifetime, NumVisits, Avgerage Spending, color based on their cluster assignment, link them to their Customer ID    ax.scatter(Lifetime, NumVists, AvgSpent, c = clusters)    #Create Plot Label Axies    ax.set_xlabel('Life Time')    ax.set_ylabel('Num Visits')    ax.set_zlabel('Avg Spent')    print "Plot Complete"    #Plot the Graph    plt.show()    plt.waitforbuttonpress()    plt.close()#-------------------------------------------------- Function for Graph Click Functionality ------------------------------------------------def onpick(event):    #Get the Master Dictionary    global MasterDict    #Detects the location of the click    thisline = event.artist    #Calls the Customer ID of the point    CustomerID = thisline.get_gid()    #If one Customer Clicked on Prints all the Information on the Customer    #If No Customers Clicked on Returns Nothing    #If A dense area clicked on Prints all the Information of all the included Customers    print 'CustomerID  :', CustomerID    print 'Information :'     print MasterDict[CustomerID]#---------------------------------------------------------------------------------------------------------------------------------------------if __name__ == "__main__":    #If you want to re-run the Data extraction == True, If data already extracted == False    ExtractNew = False    #Intialize the number of Customer Clusters you want to create    numClusters = 10    #Choose if you want to plot the customers and their info    EventPlot = False    #Choose if you want to plot the clusters and classification    ColorPlot = True     #Call Clustering Function    a = KClustering(ExtractNew, numClusters, EventPlot, ColorPlot)			